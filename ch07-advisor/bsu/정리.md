## 모델 전ㆍ후 처리 어드바이저

### Advisor
* Advisor는 Spring과 LLM 간의 상호작용을 가로채 프롬프트 응답을 변환하는 방법을 제공한다.
* LLM과의 상호작용에서 반복는 전처리 및 후처리 로직을 캡슐화하여, 재사용 가능하고 유지보수성을 높이는 역할을 한다.
* 인터셉터처럼 요청과 응답의 흐름을 가로채 전처리/후처리를 수행하며, 체인으로 요청 전처리와 응답 후처리를 순차적으로 실행한다.


| 구분 | 설명 |
| - | --- |
| 전처리 (Pre-processing)  | 애플리케이션에서 보낸 요청(request)을 AI 모델이 입력을 더 잘 이해하고 일관된 출력을 생성하도록 AI에게 올바른 질문을 하게 만드는 과정 → 프롬프트에 컨텍스트(Context, 문맥)를 추가하는 과정을 의미한다. |
| 후처리 (Post-processing) | AI 모델이 생성한 응답(response)을 검사하고, 애플리케이션이 요구하는 형식으로 변환하는 과정을 의미한다.                                                                      |

> 컨텍스트란 LLM의 응답 정확도를 높이기 위해 제공되는 정보로, 로컬 데이터, 이전 대화 내용, 현재 상황을 설명하는 텍스트 등이 될 수 있다.

Advisor는 다음과같은 공통 기능들을 손쉽게 구현할 수 있다.

- 사용자 요청을 데이터베이스에서 검색하여 프롬프트에 추가하는 기능
- 요청과 응답에 대한 안정성을 필터링하는 기능
- 사용자 위치, 날씨 등 외부 정보를 프롬프트에 추가하는 기능
- 로깅을 위한 기능

이러한 기능을 우선순위를 설정하여 체인 내에서 흐름 제어가 가능하다.

## Spring AI Advisor API

- CallAdvisor: 동기 방식으로 LLM을 호출할 때 사용된다.
- StreamAdvisor: 비동기 스트리밍 방식으로 LLM을 호출할 때 사용된다.

CallAdvisor와 StreamAdvisor는 Ordered 인터페이스를 상속하고 있어, 실행 우선순위를 지정할 수 있다. 낮은 값일수록 높은 우선순위를 가지게 되며, `HIGHEST_PRECEDENCE`와 `LOWEST_PRECEDENCE`를 통해 지정할 수 있다.

### Advisor Chain 인터페이스의 상속 관계

- `CallAdvisorChain` → `CallAdvisor`의 `adviseCall()` 메서드가 실행될 때 매개변수로 제공된다. (Advisor를 호출하기 위해 `nextCall()` 메소드를 가지고 있다)
- `StreamAdvisorChain` → `StreamAdvisor`의 `adviseStream()` 메서드가 실행될 때 매개변수로 제공된다. (Advisor를 호출하기 위해 `nextStream()` 메서드를 가지고 있다)

### Advisor 구현

| 재정의 | 설명 |
| - | --- |
| getName() | Advisor의 이름을 반환한다. |
| getOrder() | Advisor의 우선 순위를 반환한다. Ordered.HIGEST_PRECEDENCE ~ (Ordered.LOWEST_PRECEDENCE - 1) |
| adviseCall() | 동기 방식의 전처리/후처리 작업을 작성한다. |
| adviseStream() | 비동기 스트림 방식의 전처리/후처리 작업을 작성한다. |

### Ordered 인터페이스

Advisor Chain안에서 Advisor의 실행 순서를 결정하는 getOrder() 메서드를 제공한다.

```java
public class Ordered implements CallAdvisor {
	private int order;

  public Ordered(int order) {
	    this.order = order;
	}

@Override
  public int getOrder() {
      return order;
  }
}
```

getOrder() 메서드가 반환되는 숫자가 낮을수록 Advisor Chain에서 맨 먼저 전처리를 샐행한다. 그리고 맨 마지막에 후처리를 실행한다.

```java
public class AdvisorA implements CallAdvisor {
    @Override
    public int getOrder() {
        // 가장 우선 순위가 높다. +1을 추가하면 우선 순위의 다음 순위로 지정한다
        return Ordered.HIGHEST_PRECEDENCE + 1;
    }
}
```

```java
public class AdvisorB implements CallAdvisor {
    @Override
    public int getOrder() {
        // +2 를 추가하면 AdvisorA 다음 순위로 지정된다.
        return Ordered.HIGHEST_PRECEDENCE + 2;
    }
}
```

```java
public class AdvisorB implements CallAdvisor {
    @Override
    public int getOrder() {
        // A, B, C중에 우선순위가 가장 낮다
        return Ordered.HIGHEST_PRECEDENCE + 3;
    }
}
```

getOrder()의 반환값으로 return 부분에 `return Ordered.LOWEST_PRECEDENCE;`을 사용하면 Advisor가 동작하지 않는다. `- 1;` 을 붙여 사용해야 한다.

```java
return Ordered.LOWEST_PRECEDENCE - 1;
```

### Advisor 인터페이스

Advisor 인터페이스는 getName() 메서드를 제공한다.

```java
public class Advisor implements CallAdvisor {
	@Override
	public String getName() {
	    // 현재 클래스 이름 return "Advisor"; 으로 사용해도 된다
	    return this.getClass().getSimpleName();
	}
}
```

### CallAdvisor와 CallAdvisorChain 인터페이스

CallAdvisor는 동기 호출로, adviseCall() 메서드를 통해 ChatClientRequest를 가로채고, nextCall() 메서드를 통해 다음 CallAdvisor를 호출한다.

```java
public class Advisor implements CallAdvisor {
	@Override
	public ChatClientResponse adviseCall(ChatClientRequest chatClientRequest, CallAdvisorChain callAdvisorChain) {
	    log.info("[전처리]");
	    ChatClientResponse response = callAdvisorChain.nextCall(chatClientRequest);

	    log.info("[후처리]");

	    return response;
	}
}
```

### ChatClientRequest와 ChatClientResponse 레코드

- ChatClientRequest는 요청(Prompt)정보를 가지고 있고,
- ChatClientResponse는 응답(CallResponse) 정보를 가지고 있다.

전체 체인에서 공유할 데이터를 위해 Map<String, Object> 타입의 context를 가지고 있다. `.context()`가 공유 객체이다.

### Advisor 적용

- 기본 Advisor로 추가하는 방법

```java
public class AiService {
    private ChatClient chatClient;

    public AiService(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder
        .defaultAdvisors(new AdvisorA(), new AdvisorB()) // 공통 부분: getOrder()의 우선순위
        .build();
    }
}
```

- 요청 시 마다 Advisor를 ChatClient에 추가하는 방법

```java
public class AiService {
    ...
    public String advisorChain(String question) {
        String answer = chatClient.prompt()
                .user(question)
                .advisors(new AdvisorC())
                .call()
                .content()
        return answer;
    }
}
```

추가된 어드바이저는 기본 어드바이저 2개와 `chatClient`에 추가된 어드바이저로 총 3개이다. 전처리 작업은 `AdvisorA > AdvisorB > AdvisorC` 순으로 진행되었고, 후처리 작업은 `AdvisorC > AdvisorB > AdvisorA` 순으로 진행되었다.

```java
INFO  com.example.demo.advisor.AdvisorA.adviseCall(): [전처리]
INFO  com.example.demo.advisor.AdvisorB.adviseCall(): [전처리]
INFO  com.example.demo.advisor.AdvisorC.adviseCall(): [전처리]
INFO  com.example.demo.advisor.AdvisorC.adviseCall(): [후처리]
INFO  com.example.demo.advisor.AdvisorB.adviseCall(): [후처리]
INFO  com.example.demo.advisor.AdvisorA.adviseCall(): [후처리]
```

### 공유 데이터 이용

ChatClient가 실행될 때 Advisor와 공유해야 할 데이터가 있다면 키와 값을 제공할 수 있다.

```java
chatClient.prompt()
	.advisors(advisorSpec -> advisorSpec.param("키", 값))
```

Advisor는 ChatClientRequest 또는 ChatClientResponse의 context() 메서드를 통해 공유 데이터를 Map<String, Object> 타입으로 얻고, 저장된 값을 읽고 활용할 수 있다.

### 내장 Advisor

프롬프트 전처리와 응답 후처리 과정에서 자주 사용되는 기능들을 쉽게 적용할 수 있도록 다양한 내장 Advisor를 제공한다.

* 로깅 advisor

| Advisor | 설명 |
| - | --- |
| SimpleLoggerAdvisor | ChatClient의 요청과 응답 내용을 로깅한다, AI 상호작용을 디버깅하고 모니터링을 할 때 유용하다 |

* 사용자 질문 검사 advisor

| Advisor | 설명 |
| - | --- |
| SafeGuardAdvisor | - 사용자 질문에서 민감한 단어가 포함되어 있을 경우 요청을 처리하지 않고 차단한다. |


### 로깅 Advisor

SimpleLoggerAdvisor는 ChatClient의 요청 및 응답을 로깅할 때 사용할 수 있다. `application.properties` 파일에 다음 코드를 추가한다.

```java
logging.level.org.springframework.ai.chat.client.advisor=DEBUG
```

출력 로그를 보려면 로깅 레벨을 DEBUG로 설정한다.

```java
@Service
public class AiService {
  private ChatClient chatClient;

  public AiService(ChatClient.Builder chatClientBuilder) {
      this.chatClient = chatClientBuilder
            .defaultAdvisors(
                    new MaxCharLengthAdvisor(Ordered.HIGHEST_PRECEDENCE),
                    new SimpleLoggerAdvisor(Ordered.LOWEST_PRECEDENCE - 1))
            .build();
  }
}
```

다른 Advisor보다 SimpleLoggerAdvisor의 우선순위를 제일 낮게 해서 맨 마지막에 전처리 한다.

```java
public String advisorLogging(String question) {
    String response = chatClient.prompt()
            .user(question)
            .advisors(advisorSpec -> advisorSpec.param(MaxCharLengthAdvisor.MAX_CHAR_LENGTH, 100))
            .call()
            .content();

    return response;
}
```

advisorLoggin() 메서드는 MaxCharLengthAdvisor가 최대 응답 문자 수를 100자로 제한하는 지시문을 프롬프트에 추가하고, 이 정보가 프롬프트에 반영되는지 로그를 출력한다.

```java
DEBUG o.s.a.c.c.a.SimpleLoggerAdvisor.logRequest(): request: ChatClientRequest[prompt=Prompt{messages=[UserMessage{content='Spring AI에 대해 설명해줘.
100자 이내로 답변해 주세요.', metadata={messageType=USER}, messageType=USER}], modelOptions=OpenAiChatOptions: {"streamUsage":false,"model":"gpt-4o-mini","temperature":0.7}}, context={maxCharLength=100}]
```

질문 뒤에 제하 문자 수를 100자로 제한하는 지시문이 추가되어 있는 것을 볼 수 있다.

### 세이프가드 Advisor

SafeGuardAdvisor는 프롬프트에서 민감한 단어가 포함되어 있을 경우, 요청을 차단하는 기능을 제공한다.

- sensitiveWords: 민감한 단어 목록
- failureResponse: 민감한 단어가 발결되었을 때 제공될 응답 텍스트
- order: 우선순위

```java
@Service
public class AiService4 {
  private ChatClient chatClient;

  public AiService4(ChatClient.Builder chatClientBuilder) {
      SafeGuardAdvisor safeGuardAdvisor = new SafeGuardAdvisor(
              List.of("욕설", "계좌번호", "폭력", "폭탄"),
              "해당 질문은 민감한 컨텐츠 요청이므로 응답할 수 없습니다.",
              Ordered.HIGHEST_PRECEDENCE);
      this.chatClient = chatClientBuilder
              .defaultAdvisors(safeGuardAdvisor)
              .build();
  }
}
```