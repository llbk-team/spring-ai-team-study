# Spring 정리 노트

## 📌 목차
1. [REST API 클라이언트 종류](#rest-api-클라이언트-종류)
2. [Mono와 Flux의 차이점](#mono와-flux의-차이점)
3. [Spring Web vs Reactive Web](#spring-web-vs-reactive-web)
4. [FormData의 역할](#formdata의-역할)
5. [ImageModel 인터페이스](#imagemodel-인터페이스)
6. [ImageMessage 클래스](#imagemessage-클래스)

---

## REST API 클라이언트 종류

Spring에서 외부 REST API를 호출하는 방법은 크게 3가지가 있습니다.

### 1. RestTemplate
- **처리 방식**: 동기 방식 (Synchronous)
- **특징**: 
  - Spring 3.0부터 사용
  - 전통적인 방식
  - Spring 5부터 maintenance 모드
  - 새 프로젝트에는 권장하지 않음

```java
@Service
public class ApiService {
    @Autowired
    private RestTemplate restTemplate;
    
    public String getData() {
        return restTemplate.getForObject(url, String.class);
    }
}
```

### 2. WebClient ⭐ (권장)
- **기반**: Spring WebFlux
- **처리 방식**: 비동기 + 동기 모두 지원
- **특징**:
  - Non-blocking
  - 현대적이고 유연함
  - 반응형 프로그래밍 지원
  - 가장 권장되는 방식

```java
@Service
public class ApiService {
    @Autowired
    private WebClient webClient;
    
    // 동기 방식
    public String getDataSync() {
        return webClient.get()
            .uri("/data")
            .retrieve()
            .bodyToMono(String.class)
            .block();  // 동기 처리
    }
    
    // 비동기 방식
    public Mono<String> getDataAsync() {
        return webClient.get()
            .uri("/data")
            .retrieve()
            .bodyToMono(String.class);
    }
}
```

### 3. RestClient
- **버전**: Spring 6.1+ (Spring Boot 3.2+)
- **처리 방식**: 동기 방식
- **특징**:
  - RestTemplate의 현대적 대체
  - 간단한 API
  - 동기 처리에 최적화

```java
@Service
public class ApiService {
    private final RestClient restClient;
    
    public String getData() {
        return restClient.get()
            .uri("/data")
            .retrieve()
            .body(String.class);
    }
}
```

---

## Mono와 Flux의 차이점

Spring WebFlux에서 사용하는 반응형(Reactive) 타입입니다.

### Mono<T>
- **반환 개수**: 0개 또는 1개
- **용도**: 단일 응답
- **비유**: `Optional<T>` 또는 단일 값

```java
// 단일 사용자 조회
Mono<User> findById(Long id)

// 저장 (1개 반환)
Mono<User> save(User user)

// 삭제 (결과 없음)
Mono<Void> delete(Long id)

// 개수 세기
Mono<Long> count()
```

### Flux<T>
- **반환 개수**: 0개 ~ N개 (무한대 가능)
- **용도**: 스트림 응답 (컬렉션)
- **비유**: `List<T>` 또는 `Stream<T>`

```java
// 여러 사용자 조회
Flux<User> findAll()

// 검색 결과 (여러 개)
Flux<User> search(String keyword)

// 스트리밍 데이터
Flux<Event> subscribeToEvents()
```

### 비교표

| 구분 | Mono | Flux |
|------|------|------|
| 반환 개수 | 0 또는 1개 | 0 ~ N개 |
| 응답 형태 | 단일 응답 | 스트림 응답 |
| 사용 예 | 단일 조회, 저장 | 목록 조회, 검색 |

---

## Spring Web vs Reactive Web

### Spring Web (MVC) - 동기 방식
- **특징**:
  - 전통적인 Servlet 기반
  - 동기 처리 (Synchronous)
  - Thread per Request 모델
  - Blocking I/O

```java
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);  // 동기 방식
    }
}
```

### Spring Reactive Web (WebFlux) - 비동기 방식
- **특징**:
  - Netty 기반
  - 비동기 처리 (Asynchronous)
  - Event Loop 모델
  - Non-blocking I/O
  - 높은 동시성 처리

```java
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        return userService.findById(id);  // 비동기 방식
    }
}
```

### 비교표

| 구분 | Spring Web (MVC) | Spring Reactive Web (WebFlux) |
|------|------------------|-------------------------------|
| 처리 방식 | 동기 (Synchronous) | 비동기 (Asynchronous) |
| 기반 | Servlet | Netty |
| I/O 모델 | Blocking | Non-blocking |
| 반환 타입 | 일반 객체 | Mono, Flux |
| 사용 사례 | 전통적인 CRUD | 실시간 스트리밍, 고성능 |

---

## FormData의 역할

### 개념
FormData는 폼 데이터를 키-값 쌍으로 쉽게 구성하여 서버로 전송할 수 있게 해주는 JavaScript 객체입니다.

### 주요 역할
1. **텍스트(description) + 파일(이미지 Blob)을 함께 전송**
   - 일반 텍스트 데이터
   - 파일(이미지, 문서 등)
   - 여러 데이터를 하나의 요청으로 묶어서 전송

2. **자동 인코딩**
   - `multipart/form-data` 형식으로 자동 인코딩
   - boundary(경계선) 자동 생성
   - 브라우저가 Content-Type 자동 설정

### 사용 예시

```javascript
// FormData 생성
const formData = new FormData();

// 텍스트 추가
formData.append("description", "귀여운 고양이");

// 파일 추가
const file = document.getElementById("file").files[0];
formData.append("image", file);

// 서버로 전송
fetch("/api/upload", {
    method: "POST",
    body: formData  // Content-Type은 자동 설정됨
});
```

### 전송 형식

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4

------WebKitFormBoundary7MA4
Content-Disposition: form-data; name="description"

귀여운 고양이
------WebKitFormBoundary7MA4
Content-Disposition: form-data; name="image"; filename="cat.png"
Content-Type: image/png

[이미지 바이너리 데이터]
------WebKitFormBoundary7MA4--
```

---

## ImageModel 인터페이스

### 개념
Spring AI의 ImageModel은 이미지 생성 AI 모델을 위한 인터페이스입니다.

### 특징
- **챗 모델과 유사한 사용 방식**
  - ChatModel: 텍스트 기반 대화
  - ImageModel: 이미지 생성
- **통일된 인터페이스 제공**

### 메서드

#### call() 메서드
- **용도**: 이미지 생성 요청
- **특징**: 이미지는 `call()` 메서드만 제공 (stream 없음)
- **반환**: 생성된 이미지

```java
@Service
public class ImageService {
    
    @Autowired
    private ImageModel imageModel;
    
    public ImageResponse generateImage(String prompt) {
        ImagePrompt imagePrompt = new ImagePrompt(prompt);
        
        // call() 메서드로 이미지 생성
        return imageModel.call(imagePrompt);
    }
}
```

### ChatModel vs ImageModel

| 구분 | ChatModel | ImageModel |
|------|-----------|------------|
| 입력 | 텍스트 | 텍스트 프롬프트 |
| 출력 | 텍스트 응답 | 이미지 |
| 메서드 | `call()`, `stream()` | `call()` 만 |
| 스트리밍 | 지원 (점진적 응답) | 미지원 |

---

## ImageMessage 클래스

### 개념
이미지 생성 시 사용되는 메시지 클래스로, 텍스트와 가중치를 포함합니다.

### 구성 요소

#### 1. 텍스트 (Text)
- 이미지 생성에 사용될 프롬프트
- 생성하고 싶은 이미지에 대한 설명

#### 2. 가중치 (Weight)
- 각 요소의 중요도를 나타내는 값
- **높은 가중치 → 낮은 가중치 순으로 이미지 생성**
- 이미지 생성 시 우선순위 결정

### 사용 예시

```java
@Service
public class ImageService {
    
    @Autowired
    private ImageModel imageModel;
    
    public ImageResponse generateWeightedImage() {
        // 가중치가 높은 요소부터 적용
        ImageMessage message1 = new ImageMessage(
            "cute cat",     // 텍스트
            2.0             // 가중치 (높음)
        );
        
        ImageMessage message2 = new ImageMessage(
            "wearing glasses",  // 텍스트
            1.5                 // 가중치 (중간)
        );
        
        ImageMessage message3 = new ImageMessage(
            "sitting on chair",  // 텍스트
            1.0                  // 가중치 (낮음)
        );
        
        // 가중치 순서: cute cat (2.0) → wearing glasses (1.5) → sitting on chair (1.0)
        ImagePrompt prompt = new ImagePrompt(
            List.of(message1, message2, message3)
        );
        
        return imageModel.call(prompt);
    }
}
```

### 가중치 동작 방식

```
가중치: 높음 → 낮음 순으로 이미지 생성

예시:
┌─────────────────────────────────┐
│ "cute cat"          (가중치 2.0) │  ← 가장 강하게 반영
│ "wearing glasses"   (가중치 1.5) │  ← 중간 반영
│ "sitting on chair"  (가중치 1.0) │  ← 약하게 반영
└─────────────────────────────────┘

결과: 귀여운 고양이가 가장 두드러지고,
      안경을 쓴 모습이 다음으로 강조되며,
      의자에 앉은 모습은 배경처럼 표현됨
```

### 실전 팁

```java
// 명확한 주제 설정 (높은 가중치)
ImageMessage mainSubject = new ImageMessage("portrait of a woman", 2.0);

// 스타일 지정 (중간 가중치)
ImageMessage style = new ImageMessage("oil painting style", 1.5);

// 배경 설정 (낮은 가중치)
ImageMessage background = new ImageMessage("sunset background", 1.0);

// 가중치 순서대로 이미지 생성
ImagePrompt prompt = new ImagePrompt(
    List.of(mainSubject, style, background)
);
```

---

## 📚 참고 자료

- Spring Framework Documentation
- Spring WebFlux Guide
- Spring AI Documentation
- Reactive Programming Guide

---

## 📝 학습 정리

### 핵심 개념
1. **비동기 처리**: WebClient와 WebFlux를 활용한 반응형 프로그래밍
2. **Mono vs Flux**: 단일 응답과 스트림 응답의 차이 이해
3. **FormData**: 파일과 텍스트를 함께 전송하는 메커니즘
4. **ImageModel**: AI 이미지 생성을 위한 통일된 인터페이스
5. **가중치**: 이미지 생성 시 요소별 중요도 조절

### 실무 적용
- REST API 클라이언트는 **WebClient 사용 권장**
- 비동기 처리가 필요하면 **WebFlux + Mono/Flux** 사용
- 파일 업로드는 **FormData + multipart/form-data** 활용
- 이미지 생성 시 **가중치를 활용한 세밀한 제어** 가능